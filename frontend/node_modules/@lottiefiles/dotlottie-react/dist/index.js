import React, { useState, useRef, useCallback, useMemo, useEffect, useLayoutEffect } from 'react';

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// ../../node_modules/.pnpm/debounce@2.0.0/node_modules/debounce/index.js
var require_debounce = __commonJS({
  "../../node_modules/.pnpm/debounce@2.0.0/node_modules/debounce/index.js"(exports, module) {
    function debounce2(function_, wait = 100, options = {}) {
      if (typeof function_ !== "function") {
        throw new TypeError(`Expected the first parameter to be a function, got \`${typeof function_}\`.`);
      }
      if (wait < 0) {
        throw new RangeError("`wait` must not be negative.");
      }
      const { immediate } = typeof options === "boolean" ? { immediate: options } : options;
      let storedContext;
      let storedArguments;
      let timeoutId;
      let timestamp;
      let result;
      function later() {
        const last = Date.now() - timestamp;
        if (last < wait && last >= 0) {
          timeoutId = setTimeout(later, wait - last);
        } else {
          timeoutId = void 0;
          if (!immediate) {
            const callContext = storedContext;
            const callArguments = storedArguments;
            storedContext = void 0;
            storedArguments = void 0;
            result = function_.apply(callContext, callArguments);
          }
        }
      }
      const debounced = function(...arguments_) {
        if (storedContext && this !== storedContext) {
          throw new Error("Debounced method called with different contexts.");
        }
        storedContext = this;
        storedArguments = arguments_;
        timestamp = Date.now();
        const callNow = immediate && !timeoutId;
        if (!timeoutId) {
          timeoutId = setTimeout(later, wait);
        }
        if (callNow) {
          const callContext = storedContext;
          const callArguments = storedArguments;
          storedContext = void 0;
          storedArguments = void 0;
          result = function_.apply(callContext, callArguments);
        }
        return result;
      };
      debounced.clear = () => {
        if (!timeoutId) {
          return;
        }
        clearTimeout(timeoutId);
        timeoutId = void 0;
      };
      debounced.flush = () => {
        if (!timeoutId) {
          return;
        }
        const callContext = storedContext;
        const callArguments = storedArguments;
        storedContext = void 0;
        storedArguments = void 0;
        result = function_.apply(callContext, callArguments);
        clearTimeout(timeoutId);
        timeoutId = void 0;
      };
      return debounced;
    }
    module.exports.debounce = debounce2;
    module.exports = debounce2;
  }
});

// ../web/dist/index.js
var Yi = Object.defineProperty;
var Ni = (y, a, o) => a in y ? Yi(y, a, { enumerable: true, configurable: true, writable: true, value: o }) : y[a] = o;
var F = (y, a, o) => (Ni(y, typeof a != "symbol" ? a + "" : a, o), o);
var et = class {
  requestAnimationFrame(a) {
    return requestAnimationFrame(a);
  }
  cancelAnimationFrame(a) {
    cancelAnimationFrame(a);
  }
};
var tt = class {
  constructor() {
    F(this, "_lastHandleId", 0);
    F(this, "_lastImmediate", null);
  }
  requestAnimationFrame(a) {
    return this._lastHandleId >= Number.MAX_SAFE_INTEGER && (this._lastHandleId = 0), this._lastHandleId += 1, this._lastImmediate = setImmediate(() => {
      a(Date.now());
    }), this._lastHandleId;
  }
  cancelAnimationFrame(a) {
    this._lastImmediate && clearImmediate(this._lastImmediate);
  }
};
var Se = class {
  constructor() {
    F(this, "_strategy");
    this._strategy = typeof requestAnimationFrame == "function" ? new et() : new tt();
  }
  requestAnimationFrame(a) {
    return this._strategy.requestAnimationFrame(a);
  }
  cancelAnimationFrame(a) {
    this._strategy.cancelAnimationFrame(a);
  }
};
var rt = typeof window < "u" && typeof window.document < "u";
var me = { name: "@lottiefiles/dotlottie-web", version: "0.25.0", type: "module", description: "Lottie and DotLottie player for the web", repository: { type: "git", url: "git+https://github.com/LottieFiles/dotlottie-web.git", directory: "packages/web" }, homepage: "https://github.com/LottieFiles/dotlottie-web#readme", bugs: "https://github.com/LottieFiles/dotlottie-web/issues", author: "LottieFiles", contributors: ["Abdelrahman Ashraf <a.theashraf@gmail.com>"], license: "MIT", main: "dist/index.cjs", module: "dist/index.js", types: "dist/index.d.ts", files: ["dist"], keywords: ["dotlottie", "lottie", "player", "animation", "web", "canvas", "javascript", "thorvg"], scripts: { build: "tsup", dev: "tsup --watch", lint: "eslint --fix .", "stats:eslint": "cross-env TIMING=1 eslint .", "stats:ts": "tsc -p tsconfig.build.json --extendedDiagnostics", test: "vitest run --browser.headless", "test:coverage": "vitest run --browser.headless --coverage", "test:watch": "vitest", "type-check": "tsc --noEmit" }, devDependencies: { "@types/node": "^20.10.5", "@vitest/browser": "^1.2.2 ", "@vitest/coverage-istanbul": "^1.2.2", "cross-env": "7.0.3", tsup: "8.0.1", typescript: "5.0.4", vitest: "^1.2.2", webdriverio: "^8.32.0" }, publishConfig: { access: "public" } };
var Xi = (() => {
  var y = typeof document < "u" ? document.currentScript?.src : void 0;
  return function(a = {}) {
    var o = a, h, E, N = new Promise((e, t) => {
      h = e, E = t;
    }), Q = Object.assign({}, o), st = "./this.program", lt = true, U = "";
    function er(e) {
      return o.locateFile ? o.locateFile(e, U) : U + e;
    }
    typeof document < "u" && document.currentScript && (U = document.currentScript.src), y && (U = y), U.startsWith("blob:") ? U = "" : U = U.substr(0, U.replace(/[?#].*/, "").lastIndexOf("/") + 1);
    var nr = o.print || console.log.bind(console), ee = o.printErr || console.error.bind(console);
    Object.assign(o, Q), Q = null, o.arguments && o.arguments, o.thisProgram && (st = o.thisProgram), o.quit && o.quit;
    var oe;
    o.wasmBinary && (oe = o.wasmBinary);
    var ye, ut = false, W, $, te, se, A, w, dt, ct;
    function vt() {
      var e = ye.buffer;
      o.HEAP8 = W = new Int8Array(e), o.HEAP16 = te = new Int16Array(e), o.HEAPU8 = $ = new Uint8Array(e), o.HEAPU16 = se = new Uint16Array(e), o.HEAP32 = A = new Int32Array(e), o.HEAPU32 = w = new Uint32Array(e), o.HEAPF32 = dt = new Float32Array(e), o.HEAPF64 = ct = new Float64Array(e);
    }
    var ft = [], pt = [], ht = [];
    function or() {
      if (o.preRun)
        for (typeof o.preRun == "function" && (o.preRun = [o.preRun]); o.preRun.length; )
          ur(o.preRun.shift());
      Ie(ft);
    }
    function sr() {
      Ie(pt);
    }
    function lr() {
      if (o.postRun)
        for (typeof o.postRun == "function" && (o.postRun = [o.postRun]); o.postRun.length; )
          cr(o.postRun.shift());
      Ie(ht);
    }
    function ur(e) {
      ft.unshift(e);
    }
    function dr(e) {
      pt.unshift(e);
    }
    function cr(e) {
      ht.unshift(e);
    }
    var X = 0, le = null;
    function vr(e) {
      X++, o.monitorRunDependencies?.(X);
    }
    function fr(e) {
      if (X--, o.monitorRunDependencies?.(X), X == 0 && le) {
        var t = le;
        le = null, t();
      }
    }
    function be(e) {
      o.onAbort?.(e), e = "Aborted(" + e + ")", ee(e), ut = true, e += ". Build with -sASSERTIONS for more info.";
      var t = new WebAssembly.RuntimeError(e);
      throw E(t), t;
    }
    var pr = "data:application/octet-stream;base64,", _t = (e) => e.startsWith(pr), re;
    re = "DotLottiePlayer.wasm", _t(re) || (re = er(re));
    function mt(e) {
      if (e == re && oe)
        return new Uint8Array(oe);
      throw "both async and sync fetching of the wasm failed";
    }
    function hr(e) {
      return !oe && lt && typeof fetch == "function" ? fetch(e, { credentials: "same-origin" }).then((t) => {
        if (!t.ok)
          throw `failed to load wasm binary file at '${e}'`;
        return t.arrayBuffer();
      }).catch(() => mt(e)) : Promise.resolve().then(() => mt(e));
    }
    function gt(e, t, r) {
      return hr(e).then((n) => WebAssembly.instantiate(n, t)).then(r, (n) => {
        ee(`failed to asynchronously prepare wasm: ${n}`), be(n);
      });
    }
    function _r(e, t, r, n) {
      return !e && typeof WebAssembly.instantiateStreaming == "function" && !_t(t) && typeof fetch == "function" ? fetch(t, { credentials: "same-origin" }).then((i) => {
        var s = WebAssembly.instantiateStreaming(i, r);
        return s.then(n, function(u) {
          return ee(`wasm streaming compile failed: ${u}`), ee("falling back to ArrayBuffer instantiation"), gt(t, r, n);
        });
      }) : gt(t, r, n);
    }
    function mr() {
      var e = { a: hi };
      function t(n, i) {
        return b = n.exports, ye = b.ka, vt(), kt = b.oa, dr(b.la), fr(), b;
      }
      vr();
      function r(n) {
        t(n.instance);
      }
      if (o.instantiateWasm)
        try {
          return o.instantiateWasm(e, t);
        } catch (n) {
          ee(`Module.instantiateWasm callback failed with error: ${n}`), E(n);
        }
      return _r(oe, re, e, r).catch(E), {};
    }
    var Ie = (e) => {
      for (; e.length > 0; )
        e.shift()(o);
    };
    o.noExitRuntime || true;
    var I = (e) => zt(e), j = () => Yt(), yt = typeof TextDecoder < "u" ? new TextDecoder("utf8") : void 0, bt = (e, t, r) => {
      for (var n = t + r, i = t; e[i] && !(i >= n); )
        ++i;
      if (i - t > 16 && e.buffer && yt)
        return yt.decode(e.subarray(t, i));
      for (var s = ""; t < i; ) {
        var u = e[t++];
        if (!(u & 128)) {
          s += String.fromCharCode(u);
          continue;
        }
        var l = e[t++] & 63;
        if ((u & 224) == 192) {
          s += String.fromCharCode((u & 31) << 6 | l);
          continue;
        }
        var d = e[t++] & 63;
        if ((u & 240) == 224 ? u = (u & 15) << 12 | l << 6 | d : u = (u & 7) << 18 | l << 12 | d << 6 | e[t++] & 63, u < 65536)
          s += String.fromCharCode(u);
        else {
          var v = u - 65536;
          s += String.fromCharCode(55296 | v >> 10, 56320 | v & 1023);
        }
      }
      return s;
    }, G = (e, t) => e ? bt($, e, t) : "", gr = (e, t, r, n) => {
      be(`Assertion failed: ${G(e)}, at: ` + [t ? G(t) : "unknown filename", r, n ? G(n) : "unknown function"]);
    }, ne = 0;
    class Ct {
      constructor(t) {
        this.excPtr = t, this.ptr = t - 24;
      }
      set_type(t) {
        w[this.ptr + 4 >> 2] = t;
      }
      get_type() {
        return w[this.ptr + 4 >> 2];
      }
      set_destructor(t) {
        w[this.ptr + 8 >> 2] = t;
      }
      get_destructor() {
        return w[this.ptr + 8 >> 2];
      }
      set_caught(t) {
        t = t ? 1 : 0, W[this.ptr + 12] = t;
      }
      get_caught() {
        return W[this.ptr + 12] != 0;
      }
      set_rethrown(t) {
        t = t ? 1 : 0, W[this.ptr + 13] = t;
      }
      get_rethrown() {
        return W[this.ptr + 13] != 0;
      }
      init(t, r) {
        this.set_adjusted_ptr(0), this.set_type(t), this.set_destructor(r);
      }
      set_adjusted_ptr(t) {
        w[this.ptr + 16 >> 2] = t;
      }
      get_adjusted_ptr() {
        return w[this.ptr + 16 >> 2];
      }
      get_exception_ptr() {
        var t = qt(this.get_type());
        if (t)
          return w[this.excPtr >> 2];
        var r = this.get_adjusted_ptr();
        return r !== 0 ? r : this.excPtr;
      }
    }
    var yr = (e) => {
      throw ne || (ne = e), ne;
    }, Ce = (e) => Vt(e), br = (e) => {
      var t = ne;
      if (!t)
        return Ce(0), 0;
      var r = new Ct(t);
      r.set_adjusted_ptr(t);
      var n = r.get_type();
      if (!n)
        return Ce(0), t;
      for (var i in e) {
        var s = e[i];
        if (s === 0 || s === n)
          break;
        var u = r.ptr + 16;
        if (Nt(s, n, u))
          return Ce(s), t;
      }
      return Ce(n), t;
    }, Cr = () => br([]), Er = (e, t, r) => {
      var n = new Ct(e);
      throw n.init(t, r), ne = e, ne;
    };
    function Pr(e, t, r) {
      return 0;
    }
    var Tr = (e, t) => {
    }, wt = (e) => {
      for (var t = 0, r = 0; r < e.length; ++r) {
        var n = e.charCodeAt(r);
        n <= 127 ? t++ : n <= 2047 ? t += 2 : n >= 55296 && n <= 57343 ? (t += 4, ++r) : t += 3;
      }
      return t;
    }, Et = (e, t, r, n) => {
      if (!(n > 0))
        return 0;
      for (var i = r, s = r + n - 1, u = 0; u < e.length; ++u) {
        var l = e.charCodeAt(u);
        if (l >= 55296 && l <= 57343) {
          var d = e.charCodeAt(++u);
          l = 65536 + ((l & 1023) << 10) | d & 1023;
        }
        if (l <= 127) {
          if (r >= s)
            break;
          t[r++] = l;
        } else if (l <= 2047) {
          if (r + 1 >= s)
            break;
          t[r++] = 192 | l >> 6, t[r++] = 128 | l & 63;
        } else if (l <= 65535) {
          if (r + 2 >= s)
            break;
          t[r++] = 224 | l >> 12, t[r++] = 128 | l >> 6 & 63, t[r++] = 128 | l & 63;
        } else {
          if (r + 3 >= s)
            break;
          t[r++] = 240 | l >> 18, t[r++] = 128 | l >> 12 & 63, t[r++] = 128 | l >> 6 & 63, t[r++] = 128 | l & 63;
        }
      }
      return t[r] = 0, r - i;
    }, Fr = (e, t, r) => Et(e, $, t, r), Lr = (e, t) => {
    };
    function $r(e, t, r) {
      return 0;
    }
    var Mr = (e, t, r, n) => {
    };
    function Ar(e, t, r, n) {
    }
    var Sr = (e, t) => {
    }, we = {}, Oe = (e) => {
      for (; e.length; ) {
        var t = e.pop(), r = e.pop();
        r(t);
      }
    };
    function ue(e) {
      return this.fromWireType(w[e >> 2]);
    }
    var ie = {}, J = {}, Ee = {}, Pt, Pe = (e) => {
      throw new Pt(e);
    }, q = (e, t, r) => {
      e.forEach(function(l) {
        Ee[l] = t;
      });
      function n(l) {
        var d = r(l);
        d.length !== e.length && Pe("Mismatched type converter count");
        for (var v = 0; v < e.length; ++v)
          H(e[v], d[v]);
      }
      var i = new Array(t.length), s = [], u = 0;
      t.forEach((l, d) => {
        J.hasOwnProperty(l) ? i[d] = J[l] : (s.push(l), ie.hasOwnProperty(l) || (ie[l] = []), ie[l].push(() => {
          i[d] = J[l], ++u, u === s.length && n(i);
        }));
      }), s.length === 0 && n(i);
    }, kr = (e) => {
      var t = we[e];
      delete we[e];
      var r = t.rawConstructor, n = t.rawDestructor, i = t.fields, s = i.map((u) => u.getterReturnType).concat(i.map((u) => u.setterArgumentType));
      q([e], s, (u) => {
        var l = {};
        return i.forEach((d, v) => {
          var f = d.fieldName, m = u[v], _ = d.getter, C = d.getterContext, T = u[v + i.length], O = d.setter, S = d.setterContext;
          l[f] = { read: (L) => m.fromWireType(_(C, L)), write: (L, c) => {
            var p = [];
            O(S, L, T.toWireType(p, c)), Oe(p);
          } };
        }), [{ name: t.name, fromWireType: (d) => {
          var v = {};
          for (var f in l)
            v[f] = l[f].read(d);
          return n(d), v;
        }, toWireType: (d, v) => {
          for (var f in l)
            if (!(f in v))
              throw new TypeError(`Missing field: "${f}"`);
          var m = r();
          for (f in l)
            l[f].write(m, v[f]);
          return d !== null && d.push(n, m), m;
        }, argPackAdvance: B, readValueFromPointer: ue, destructorFunction: n }];
      });
    }, Rr = (e, t, r, n, i) => {
    }, xr = () => {
      for (var e = new Array(256), t = 0; t < 256; ++t)
        e[t] = String.fromCharCode(t);
      Tt = e;
    }, Tt, M = (e) => {
      for (var t = "", r = e; $[r]; )
        t += Tt[$[r++]];
      return t;
    }, ae, g = (e) => {
      throw new ae(e);
    };
    function Dr(e, t, r = {}) {
      var n = t.name;
      if (e || g(`type "${n}" must have a positive integer typeid pointer`), J.hasOwnProperty(e)) {
        if (r.ignoreDuplicateRegistrations)
          return;
        g(`Cannot register type '${n}' twice`);
      }
      if (J[e] = t, delete Ee[e], ie.hasOwnProperty(e)) {
        var i = ie[e];
        delete ie[e], i.forEach((s) => s());
      }
    }
    function H(e, t, r = {}) {
      if (!("argPackAdvance" in t))
        throw new TypeError("registerType registeredInstance requires argPackAdvance");
      return Dr(e, t, r);
    }
    var B = 8, Ir = (e, t, r, n) => {
      t = M(t), H(e, { name: t, fromWireType: function(i) {
        return !!i;
      }, toWireType: function(i, s) {
        return s ? r : n;
      }, argPackAdvance: B, readValueFromPointer: function(i) {
        return this.fromWireType($[i]);
      }, destructorFunction: null });
    }, jr = (e) => ({ count: e.count, deleteScheduled: e.deleteScheduled, preservePointerOnDelete: e.preservePointerOnDelete, ptr: e.ptr, ptrType: e.ptrType, smartPtr: e.smartPtr, smartPtrType: e.smartPtrType }), We = (e) => {
      function t(r) {
        return r.$$.ptrType.registeredClass.name;
      }
      g(t(e) + " instance already deleted");
    }, Ue = false, Ft = (e) => {
    }, Or = (e) => {
      e.smartPtr ? e.smartPtrType.rawDestructor(e.smartPtr) : e.ptrType.registeredClass.rawDestructor(e.ptr);
    }, Lt = (e) => {
      e.count.value -= 1;
      var t = e.count.value === 0;
      t && Or(e);
    }, $t = (e, t, r) => {
      if (t === r)
        return e;
      if (r.baseClass === void 0)
        return null;
      var n = $t(e, t, r.baseClass);
      return n === null ? null : r.downcast(n);
    }, Mt = {}, Wr = () => Object.keys(ve).length, Ur = () => {
      var e = [];
      for (var t in ve)
        ve.hasOwnProperty(t) && e.push(ve[t]);
      return e;
    }, de = [], He = () => {
      for (; de.length; ) {
        var e = de.pop();
        e.$$.deleteScheduled = false, e.delete();
      }
    }, ce, Hr = (e) => {
      ce = e, de.length && ce && ce(He);
    }, Br = () => {
      o.getInheritedInstanceCount = Wr, o.getLiveInheritedInstances = Ur, o.flushPendingDeletes = He, o.setDelayFunction = Hr;
    }, ve = {}, Vr = (e, t) => {
      for (t === void 0 && g("ptr should not be undefined"); e.baseClass; )
        t = e.upcast(t), e = e.baseClass;
      return t;
    }, zr = (e, t) => (t = Vr(e, t), ve[t]), Te = (e, t) => {
      (!t.ptrType || !t.ptr) && Pe("makeClassHandle requires ptr and ptrType");
      var r = !!t.smartPtrType, n = !!t.smartPtr;
      return r !== n && Pe("Both smartPtrType and smartPtr must be specified"), t.count = { value: 1 }, fe(Object.create(e, { $$: { value: t, writable: true } }));
    };
    function Yr(e) {
      var t = this.getPointee(e);
      if (!t)
        return this.destructor(e), null;
      var r = zr(this.registeredClass, t);
      if (r !== void 0) {
        if (r.$$.count.value === 0)
          return r.$$.ptr = t, r.$$.smartPtr = e, r.clone();
        var n = r.clone();
        return this.destructor(e), n;
      }
      function i() {
        return this.isSmartPointer ? Te(this.registeredClass.instancePrototype, { ptrType: this.pointeeType, ptr: t, smartPtrType: this, smartPtr: e }) : Te(this.registeredClass.instancePrototype, { ptrType: this, ptr: e });
      }
      var s = this.registeredClass.getActualType(t), u = Mt[s];
      if (!u)
        return i.call(this);
      var l;
      this.isConst ? l = u.constPointerType : l = u.pointerType;
      var d = $t(t, this.registeredClass, l.registeredClass);
      return d === null ? i.call(this) : this.isSmartPointer ? Te(l.registeredClass.instancePrototype, { ptrType: l, ptr: d, smartPtrType: this, smartPtr: e }) : Te(l.registeredClass.instancePrototype, { ptrType: l, ptr: d });
    }
    var fe = (e) => typeof FinalizationRegistry > "u" ? (fe = (t) => t, e) : (Ue = new FinalizationRegistry((t) => {
      Lt(t.$$);
    }), fe = (t) => {
      var r = t.$$, n = !!r.smartPtr;
      if (n) {
        var i = { $$: r };
        Ue.register(t, i, t);
      }
      return t;
    }, Ft = (t) => Ue.unregister(t), fe(e)), Nr = () => {
      Object.assign(Fe.prototype, { isAliasOf(e) {
        if (!(this instanceof Fe) || !(e instanceof Fe))
          return false;
        var t = this.$$.ptrType.registeredClass, r = this.$$.ptr;
        e.$$ = e.$$;
        for (var n = e.$$.ptrType.registeredClass, i = e.$$.ptr; t.baseClass; )
          r = t.upcast(r), t = t.baseClass;
        for (; n.baseClass; )
          i = n.upcast(i), n = n.baseClass;
        return t === n && r === i;
      }, clone() {
        if (this.$$.ptr || We(this), this.$$.preservePointerOnDelete)
          return this.$$.count.value += 1, this;
        var e = fe(Object.create(Object.getPrototypeOf(this), { $$: { value: jr(this.$$) } }));
        return e.$$.count.value += 1, e.$$.deleteScheduled = false, e;
      }, delete() {
        this.$$.ptr || We(this), this.$$.deleteScheduled && !this.$$.preservePointerOnDelete && g("Object already scheduled for deletion"), Ft(this), Lt(this.$$), this.$$.preservePointerOnDelete || (this.$$.smartPtr = void 0, this.$$.ptr = void 0);
      }, isDeleted() {
        return !this.$$.ptr;
      }, deleteLater() {
        return this.$$.ptr || We(this), this.$$.deleteScheduled && !this.$$.preservePointerOnDelete && g("Object already scheduled for deletion"), de.push(this), de.length === 1 && ce && ce(He), this.$$.deleteScheduled = true, this;
      } });
    };
    function Fe() {
    }
    var pe = (e, t) => Object.defineProperty(t, "name", { value: e }), At = (e, t, r) => {
      if (e[t].overloadTable === void 0) {
        var n = e[t];
        e[t] = function(...i) {
          return e[t].overloadTable.hasOwnProperty(i.length) || g(`Function '${r}' called with an invalid number of arguments (${i.length}) - expects one of (${e[t].overloadTable})!`), e[t].overloadTable[i.length].apply(this, i);
        }, e[t].overloadTable = [], e[t].overloadTable[n.argCount] = n;
      }
    }, Be = (e, t, r) => {
      o.hasOwnProperty(e) ? ((r === void 0 || o[e].overloadTable !== void 0 && o[e].overloadTable[r] !== void 0) && g(`Cannot register public name '${e}' twice`), At(o, e, e), o.hasOwnProperty(r) && g(`Cannot register multiple overloads of a function with the same number of arguments (${r})!`), o[e].overloadTable[r] = t) : (o[e] = t, r !== void 0 && (o[e].numArguments = r));
    }, qr = 48, Xr = 57, Gr = (e) => {
      if (e === void 0)
        return "_unknown";
      e = e.replace(/[^a-zA-Z0-9_]/g, "$");
      var t = e.charCodeAt(0);
      return t >= qr && t <= Xr ? `_${e}` : e;
    };
    function Jr(e, t, r, n, i, s, u, l) {
      this.name = e, this.constructor = t, this.instancePrototype = r, this.rawDestructor = n, this.baseClass = i, this.getActualType = s, this.upcast = u, this.downcast = l, this.pureVirtualFunctions = [];
    }
    var Ve = (e, t, r) => {
      for (; t !== r; )
        t.upcast || g(`Expected null or instance of ${r.name}, got an instance of ${t.name}`), e = t.upcast(e), t = t.baseClass;
      return e;
    };
    function Kr(e, t) {
      if (t === null)
        return this.isReference && g(`null is not a valid ${this.name}`), 0;
      t.$$ || g(`Cannot pass "${Ge(t)}" as a ${this.name}`), t.$$.ptr || g(`Cannot pass deleted object as a pointer of type ${this.name}`);
      var r = t.$$.ptrType.registeredClass, n = Ve(t.$$.ptr, r, this.registeredClass);
      return n;
    }
    function Zr(e, t) {
      var r;
      if (t === null)
        return this.isReference && g(`null is not a valid ${this.name}`), this.isSmartPointer ? (r = this.rawConstructor(), e !== null && e.push(this.rawDestructor, r), r) : 0;
      (!t || !t.$$) && g(`Cannot pass "${Ge(t)}" as a ${this.name}`), t.$$.ptr || g(`Cannot pass deleted object as a pointer of type ${this.name}`), !this.isConst && t.$$.ptrType.isConst && g(`Cannot convert argument of type ${t.$$.smartPtrType ? t.$$.smartPtrType.name : t.$$.ptrType.name} to parameter type ${this.name}`);
      var n = t.$$.ptrType.registeredClass;
      if (r = Ve(t.$$.ptr, n, this.registeredClass), this.isSmartPointer)
        switch (t.$$.smartPtr === void 0 && g("Passing raw pointer to smart pointer is illegal"), this.sharingPolicy) {
          case 0:
            t.$$.smartPtrType === this ? r = t.$$.smartPtr : g(`Cannot convert argument of type ${t.$$.smartPtrType ? t.$$.smartPtrType.name : t.$$.ptrType.name} to parameter type ${this.name}`);
            break;
          case 1:
            r = t.$$.smartPtr;
            break;
          case 2:
            if (t.$$.smartPtrType === this)
              r = t.$$.smartPtr;
            else {
              var i = t.clone();
              r = this.rawShare(r, K.toHandle(() => i.delete())), e !== null && e.push(this.rawDestructor, r);
            }
            break;
          default:
            g("Unsupporting sharing policy");
        }
      return r;
    }
    function Qr(e, t) {
      if (t === null)
        return this.isReference && g(`null is not a valid ${this.name}`), 0;
      t.$$ || g(`Cannot pass "${Ge(t)}" as a ${this.name}`), t.$$.ptr || g(`Cannot pass deleted object as a pointer of type ${this.name}`), t.$$.ptrType.isConst && g(`Cannot convert argument of type ${t.$$.ptrType.name} to parameter type ${this.name}`);
      var r = t.$$.ptrType.registeredClass, n = Ve(t.$$.ptr, r, this.registeredClass);
      return n;
    }
    var en = () => {
      Object.assign(he.prototype, { getPointee(e) {
        return this.rawGetPointee && (e = this.rawGetPointee(e)), e;
      }, destructor(e) {
        this.rawDestructor?.(e);
      }, argPackAdvance: B, readValueFromPointer: ue, fromWireType: Yr });
    };
    function he(e, t, r, n, i, s, u, l, d, v, f) {
      this.name = e, this.registeredClass = t, this.isReference = r, this.isConst = n, this.isSmartPointer = i, this.pointeeType = s, this.sharingPolicy = u, this.rawGetPointee = l, this.rawConstructor = d, this.rawShare = v, this.rawDestructor = f, !i && t.baseClass === void 0 ? n ? (this.toWireType = Kr, this.destructorFunction = null) : (this.toWireType = Qr, this.destructorFunction = null) : this.toWireType = Zr;
    }
    var St = (e, t, r) => {
      o.hasOwnProperty(e) || Pe("Replacing nonexistent public symbol"), o[e].overloadTable !== void 0 && r !== void 0 ? o[e].overloadTable[r] = t : (o[e] = t, o[e].argCount = r);
    }, tn = (e, t, r) => {
      e = e.replace(/p/g, "i");
      var n = o["dynCall_" + e];
      return n(t, ...r);
    }, kt, R = (e) => kt.get(e), rn = (e, t, r = []) => {
      if (e.includes("j"))
        return tn(e, t, r);
      var n = R(t)(...r);
      return n;
    }, nn = (e, t) => (...r) => rn(e, t, r), x = (e, t) => {
      e = M(e);
      function r() {
        return e.includes("j") ? nn(e, t) : R(t);
      }
      var n = r();
      return typeof n != "function" && g(`unknown function pointer with signature ${e}: ${t}`), n;
    }, an = (e, t) => {
      var r = pe(t, function(n) {
        this.name = t, this.message = n;
        var i = new Error(n).stack;
        i !== void 0 && (this.stack = this.toString() + `
` + i.replace(/^Error(:[^\n]*)?\n/, ""));
      });
      return r.prototype = Object.create(e.prototype), r.prototype.constructor = r, r.prototype.toString = function() {
        return this.message === void 0 ? this.name : `${this.name}: ${this.message}`;
      }, r;
    }, Rt, xt = (e) => {
      var t = Bt(e), r = M(t);
      return z(t), r;
    }, Le = (e, t) => {
      var r = [], n = {};
      function i(s) {
        if (!n[s] && !J[s]) {
          if (Ee[s]) {
            Ee[s].forEach(i);
            return;
          }
          r.push(s), n[s] = true;
        }
      }
      throw t.forEach(i), new Rt(`${e}: ` + r.map(xt).join([", "]));
    }, on = (e, t, r, n, i, s, u, l, d, v, f, m, _) => {
      f = M(f), s = x(i, s), l && (l = x(u, l)), v && (v = x(d, v)), _ = x(m, _);
      var C = Gr(f);
      Be(C, function() {
        Le(`Cannot construct ${f} due to unbound types`, [n]);
      }), q([e, t, r], n ? [n] : [], (T) => {
        var Ae;
        T = T[0];
        var O, S;
        n ? (O = T.registeredClass, S = O.instancePrototype) : S = Fe.prototype;
        var L = pe(f, function(...Qe) {
          if (Object.getPrototypeOf(this) !== c)
            throw new ae("Use 'new' to construct " + f);
          if (p.constructor_body === void 0)
            throw new ae(f + " has no accessible constructor");
          var Jt = p.constructor_body[Qe.length];
          if (Jt === void 0)
            throw new ae(`Tried to invoke ctor of ${f} with invalid number of parameters (${Qe.length}) - expected (${Object.keys(p.constructor_body).toString()}) parameters instead!`);
          return Jt.apply(this, Qe);
        }), c = Object.create(S, { constructor: { value: L } });
        L.prototype = c;
        var p = new Jr(f, L, c, _, O, s, l, v);
        p.baseClass && ((Ae = p.baseClass).__derivedClasses ?? (Ae.__derivedClasses = []), p.baseClass.__derivedClasses.push(p));
        var k = new he(f, p, true, false, false), P = new he(f + "*", p, false, false, false), Y = new he(f + " const*", p, false, true, false);
        return Mt[e] = { pointerType: P, constPointerType: Y }, St(C, L), [k, P, Y];
      });
    }, ze = (e, t) => {
      for (var r = [], n = 0; n < e; n++)
        r.push(w[t + n * 4 >> 2]);
      return r;
    };
    function sn(e) {
      for (var t = 1; t < e.length; ++t)
        if (e[t] !== null && e[t].destructorFunction === void 0)
          return true;
      return false;
    }
    function Ye(e, t, r, n, i, s) {
      var u = t.length;
      u < 2 && g("argTypes array size mismatch! Must at least get return value and 'this' types!");
      var l = t[1] !== null && r !== null, d = sn(t), v = t[0].name !== "void", f = u - 2, m = new Array(f), _ = [], C = [], T = function(...O) {
        O.length !== f && g(`function ${e} called with ${O.length} arguments, expected ${f}`), C.length = 0;
        var S;
        _.length = l ? 2 : 1, _[0] = i, l && (S = t[1].toWireType(C, this), _[1] = S);
        for (var L = 0; L < f; ++L)
          m[L] = t[L + 2].toWireType(C, O[L]), _.push(m[L]);
        var c = n(..._);
        function p(k) {
          if (d)
            Oe(C);
          else
            for (var P = l ? 1 : 2; P < t.length; P++) {
              var Y = P === 1 ? S : m[P - 2];
              t[P].destructorFunction !== null && t[P].destructorFunction(Y);
            }
          if (v)
            return t[0].fromWireType(k);
        }
        return p(c);
      };
      return pe(e, T);
    }
    var ln = (e, t, r, n, i, s) => {
      var u = ze(t, r);
      i = x(n, i), q([], [e], (l) => {
        l = l[0];
        var d = `constructor ${l.name}`;
        if (l.registeredClass.constructor_body === void 0 && (l.registeredClass.constructor_body = []), l.registeredClass.constructor_body[t - 1] !== void 0)
          throw new ae(`Cannot register multiple constructors with identical number of parameters (${t - 1}) for class '${l.name}'! Overload resolution is currently only performed using the parameter count, not actual type info!`);
        return l.registeredClass.constructor_body[t - 1] = () => {
          Le(`Cannot construct ${l.name} due to unbound types`, u);
        }, q([], u, (v) => (v.splice(1, 0, null), l.registeredClass.constructor_body[t - 1] = Ye(d, v, null, i, s), [])), [];
      });
    }, Dt = (e) => {
      e = e.trim();
      let t = e.indexOf("(");
      return t !== -1 ? e.substr(0, t) : e;
    }, un = (e, t, r, n, i, s, u, l, d) => {
      var v = ze(r, n);
      t = M(t), t = Dt(t), s = x(i, s), q([], [e], (f) => {
        f = f[0];
        var m = `${f.name}.${t}`;
        t.startsWith("@@") && (t = Symbol[t.substring(2)]), l && f.registeredClass.pureVirtualFunctions.push(t);
        function _() {
          Le(`Cannot call ${m} due to unbound types`, v);
        }
        var C = f.registeredClass.instancePrototype, T = C[t];
        return T === void 0 || T.overloadTable === void 0 && T.className !== f.name && T.argCount === r - 2 ? (_.argCount = r - 2, _.className = f.name, C[t] = _) : (At(C, t, m), C[t].overloadTable[r - 2] = _), q([], v, (O) => {
          var S = Ye(m, O, f, s, u);
          return C[t].overloadTable === void 0 ? (S.argCount = r - 2, C[t] = S) : C[t].overloadTable[r - 2] = S, [];
        }), [];
      });
    }, Ne = [], V = [], qe = (e) => {
      e > 9 && --V[e + 1] === 0 && (V[e] = void 0, Ne.push(e));
    }, dn = () => V.length / 2 - 5 - Ne.length, cn = () => {
      V.push(0, 1, void 0, 1, null, 1, true, 1, false, 1), o.count_emval_handles = dn;
    }, K = { toValue: (e) => (e || g("Cannot use deleted val. handle = " + e), V[e]), toHandle: (e) => {
      switch (e) {
        case void 0:
          return 2;
        case null:
          return 4;
        case true:
          return 6;
        case false:
          return 8;
        default: {
          let t = Ne.pop() || V.length;
          return V[t] = e, V[t + 1] = 1, t;
        }
      }
    } }, vn = { name: "emscripten::val", fromWireType: (e) => {
      var t = K.toValue(e);
      return qe(e), t;
    }, toWireType: (e, t) => K.toHandle(t), argPackAdvance: B, readValueFromPointer: ue, destructorFunction: null }, It = (e) => H(e, vn), fn = (e, t, r) => {
      switch (t) {
        case 1:
          return r ? function(n) {
            return this.fromWireType(W[n]);
          } : function(n) {
            return this.fromWireType($[n]);
          };
        case 2:
          return r ? function(n) {
            return this.fromWireType(te[n >> 1]);
          } : function(n) {
            return this.fromWireType(se[n >> 1]);
          };
        case 4:
          return r ? function(n) {
            return this.fromWireType(A[n >> 2]);
          } : function(n) {
            return this.fromWireType(w[n >> 2]);
          };
        default:
          throw new TypeError(`invalid integer width (${t}): ${e}`);
      }
    }, pn = (e, t, r, n) => {
      t = M(t);
      function i() {
      }
      i.values = {}, H(e, { name: t, constructor: i, fromWireType: function(s) {
        return this.constructor.values[s];
      }, toWireType: (s, u) => u.value, argPackAdvance: B, readValueFromPointer: fn(t, r, n), destructorFunction: null }), Be(t, i);
    }, Xe = (e, t) => {
      var r = J[e];
      return r === void 0 && g(`${t} has unknown type ${xt(e)}`), r;
    }, hn = (e, t, r) => {
      var n = Xe(e, "enum");
      t = M(t);
      var i = n.constructor, s = Object.create(n.constructor.prototype, { value: { value: r }, constructor: { value: pe(`${n.name}_${t}`, function() {
      }) } });
      i.values[r] = s, i[t] = s;
    }, Ge = (e) => {
      if (e === null)
        return "null";
      var t = typeof e;
      return t === "object" || t === "array" || t === "function" ? e.toString() : "" + e;
    }, _n = (e, t) => {
      switch (t) {
        case 4:
          return function(r) {
            return this.fromWireType(dt[r >> 2]);
          };
        case 8:
          return function(r) {
            return this.fromWireType(ct[r >> 3]);
          };
        default:
          throw new TypeError(`invalid float width (${t}): ${e}`);
      }
    }, mn = (e, t, r) => {
      t = M(t), H(e, { name: t, fromWireType: (n) => n, toWireType: (n, i) => i, argPackAdvance: B, readValueFromPointer: _n(t, r), destructorFunction: null });
    }, gn = (e, t, r, n, i, s, u) => {
      var l = ze(t, r);
      e = M(e), e = Dt(e), i = x(n, i), Be(e, function() {
        Le(`Cannot call ${e} due to unbound types`, l);
      }, t - 1), q([], l, (d) => {
        var v = [d[0], null].concat(d.slice(1));
        return St(e, Ye(e, v, null, i, s), t - 1), [];
      });
    }, yn = (e, t, r) => {
      switch (t) {
        case 1:
          return r ? (n) => W[n] : (n) => $[n];
        case 2:
          return r ? (n) => te[n >> 1] : (n) => se[n >> 1];
        case 4:
          return r ? (n) => A[n >> 2] : (n) => w[n >> 2];
        default:
          throw new TypeError(`invalid integer width (${t}): ${e}`);
      }
    }, bn = (e, t, r, n, i) => {
      t = M(t);
      var s = (f) => f;
      if (n === 0) {
        var u = 32 - 8 * r;
        s = (f) => f << u >>> u;
      }
      var l = t.includes("unsigned"), d = (f, m) => {
      }, v;
      l ? v = function(f, m) {
        return d(m, this.name), m >>> 0;
      } : v = function(f, m) {
        return d(m, this.name), m;
      }, H(e, { name: t, fromWireType: s, toWireType: v, argPackAdvance: B, readValueFromPointer: yn(t, r, n !== 0), destructorFunction: null });
    }, Cn = (e, t, r) => {
      var n = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], i = n[t];
      function s(u) {
        var l = w[u >> 2], d = w[u + 4 >> 2];
        return new i(W.buffer, d, l);
      }
      r = M(r), H(e, { name: r, fromWireType: s, argPackAdvance: B, readValueFromPointer: s }, { ignoreDuplicateRegistrations: true });
    }, wn = (e, t) => {
      It(e);
    }, En = (e, t, r, n, i, s, u, l, d, v, f, m) => {
      r = M(r), s = x(i, s), l = x(u, l), v = x(d, v), m = x(f, m), q([e], [t], (_) => {
        _ = _[0];
        var C = new he(r, _.registeredClass, false, false, true, _, n, s, l, v, m);
        return [C];
      });
    }, Pn = (e, t) => {
      t = M(t);
      var r = t === "std::string";
      H(e, { name: t, fromWireType(n) {
        var i = w[n >> 2], s = n + 4, u;
        if (r)
          for (var l = s, d = 0; d <= i; ++d) {
            var v = s + d;
            if (d == i || $[v] == 0) {
              var f = v - l, m = G(l, f);
              u === void 0 ? u = m : (u += "\0", u += m), l = v + 1;
            }
          }
        else {
          for (var _ = new Array(i), d = 0; d < i; ++d)
            _[d] = String.fromCharCode($[s + d]);
          u = _.join("");
        }
        return z(n), u;
      }, toWireType(n, i) {
        i instanceof ArrayBuffer && (i = new Uint8Array(i));
        var s, u = typeof i == "string";
        u || i instanceof Uint8Array || i instanceof Uint8ClampedArray || i instanceof Int8Array || g("Cannot pass non-string to std::string"), r && u ? s = wt(i) : s = i.length;
        var l = Ze(4 + s + 1), d = l + 4;
        if (w[l >> 2] = s, r && u)
          Fr(i, d, s + 1);
        else if (u)
          for (var v = 0; v < s; ++v) {
            var f = i.charCodeAt(v);
            f > 255 && (z(d), g("String has UTF-16 code units that do not fit in 8 bits")), $[d + v] = f;
          }
        else
          for (var v = 0; v < s; ++v)
            $[d + v] = i[v];
        return n !== null && n.push(z, l), l;
      }, argPackAdvance: B, readValueFromPointer: ue, destructorFunction(n) {
        z(n);
      } });
    }, jt = typeof TextDecoder < "u" ? new TextDecoder("utf-16le") : void 0, Tn = (e, t) => {
      for (var r = e, n = r >> 1, i = n + t / 2; !(n >= i) && se[n]; )
        ++n;
      if (r = n << 1, r - e > 32 && jt)
        return jt.decode($.subarray(e, r));
      for (var s = "", u = 0; !(u >= t / 2); ++u) {
        var l = te[e + u * 2 >> 1];
        if (l == 0)
          break;
        s += String.fromCharCode(l);
      }
      return s;
    }, Fn = (e, t, r) => {
      if (r ?? (r = 2147483647), r < 2)
        return 0;
      r -= 2;
      for (var n = t, i = r < e.length * 2 ? r / 2 : e.length, s = 0; s < i; ++s) {
        var u = e.charCodeAt(s);
        te[t >> 1] = u, t += 2;
      }
      return te[t >> 1] = 0, t - n;
    }, Ln = (e) => e.length * 2, $n = (e, t) => {
      for (var r = 0, n = ""; !(r >= t / 4); ) {
        var i = A[e + r * 4 >> 2];
        if (i == 0)
          break;
        if (++r, i >= 65536) {
          var s = i - 65536;
          n += String.fromCharCode(55296 | s >> 10, 56320 | s & 1023);
        } else
          n += String.fromCharCode(i);
      }
      return n;
    }, Mn = (e, t, r) => {
      if (r ?? (r = 2147483647), r < 4)
        return 0;
      for (var n = t, i = n + r - 4, s = 0; s < e.length; ++s) {
        var u = e.charCodeAt(s);
        if (u >= 55296 && u <= 57343) {
          var l = e.charCodeAt(++s);
          u = 65536 + ((u & 1023) << 10) | l & 1023;
        }
        if (A[t >> 2] = u, t += 4, t + 4 > i)
          break;
      }
      return A[t >> 2] = 0, t - n;
    }, An = (e) => {
      for (var t = 0, r = 0; r < e.length; ++r) {
        var n = e.charCodeAt(r);
        n >= 55296 && n <= 57343 && ++r, t += 4;
      }
      return t;
    }, Sn = (e, t, r) => {
      r = M(r);
      var n, i, s, u;
      t === 2 ? (n = Tn, i = Fn, u = Ln, s = (l) => se[l >> 1]) : t === 4 && (n = $n, i = Mn, u = An, s = (l) => w[l >> 2]), H(e, { name: r, fromWireType: (l) => {
        for (var d = w[l >> 2], v, f = l + 4, m = 0; m <= d; ++m) {
          var _ = l + 4 + m * t;
          if (m == d || s(_) == 0) {
            var C = _ - f, T = n(f, C);
            v === void 0 ? v = T : (v += "\0", v += T), f = _ + t;
          }
        }
        return z(l), v;
      }, toWireType: (l, d) => {
        typeof d != "string" && g(`Cannot pass non-string to C++ string type ${r}`);
        var v = u(d), f = Ze(4 + v + t);
        return w[f >> 2] = v / t, i(d, f + 4, v + t), l !== null && l.push(z, f), f;
      }, argPackAdvance: B, readValueFromPointer: ue, destructorFunction(l) {
        z(l);
      } });
    }, kn = (e, t, r, n, i, s) => {
      we[e] = { name: M(t), rawConstructor: x(r, n), rawDestructor: x(i, s), fields: [] };
    }, Rn = (e, t, r, n, i, s, u, l, d, v) => {
      we[e].fields.push({ fieldName: M(t), getterReturnType: r, getter: x(n, i), getterContext: s, setterArgumentType: u, setter: x(l, d), setterContext: v });
    }, xn = (e, t) => {
      t = M(t), H(e, { isVoid: true, name: t, argPackAdvance: 0, fromWireType: () => {
      }, toWireType: (r, n) => {
      } });
    }, Dn = (e, t, r) => $.copyWithin(e, t, t + r), In = () => {
      throw 1 / 0;
    }, Je = [], jn = (e, t, r, n) => (e = Je[e], t = K.toValue(t), e(null, t, r, n)), On = (e) => {
      var t = Je.length;
      return Je.push(e), t;
    }, Wn = (e, t) => {
      for (var r = new Array(e), n = 0; n < e; ++n)
        r[n] = Xe(w[t + n * 4 >> 2], "parameter " + n);
      return r;
    }, Un = Reflect.construct, Hn = (e, t, r) => {
      var n = [], i = e.toWireType(n, r);
      return n.length && (w[t >> 2] = K.toHandle(n)), i;
    }, Bn = (e, t, r) => {
      var n = Wn(e, t), i = n.shift();
      e--;
      var s = new Array(e), u = (d, v, f, m) => {
        for (var _ = 0, C = 0; C < e; ++C)
          s[C] = n[C].readValueFromPointer(m + _), _ += n[C].argPackAdvance;
        var T = r === 1 ? Un(v, s) : v.apply(d, s);
        return Hn(i, f, T);
      }, l = `methodCaller<(${n.map((d) => d.name).join(", ")}) => ${i.name}>`;
      return On(pe(l, u));
    }, Vn = (e) => {
      e > 9 && (V[e + 1] += 1);
    }, zn = (e) => {
      var t = K.toValue(e);
      Oe(t), qe(e);
    }, Yn = (e, t) => {
      e = Xe(e, "_emval_take_value");
      var r = e.readValueFromPointer(t);
      return K.toHandle(r);
    }, Nn = () => {
      be("");
    }, Ot;
    Ot = () => performance.now();
    var qn = () => 2147483648, Xn = (e) => {
      var t = ye.buffer, r = (e - t.byteLength + 65535) / 65536;
      try {
        return ye.grow(r), vt(), 1;
      } catch {
      }
    }, Gn = (e) => {
      var t = $.length;
      e >>>= 0;
      var r = qn();
      if (e > r)
        return false;
      for (var n = (d, v) => d + (v - d % v) % v, i = 1; i <= 4; i *= 2) {
        var s = t * (1 + 0.2 / i);
        s = Math.min(s, e + 100663296);
        var u = Math.min(r, n(Math.max(e, s), 65536)), l = Xn(u);
        if (l)
          return true;
      }
      return false;
    }, Ke = {}, Jn = () => st || "./this.program", _e = () => {
      if (!_e.strings) {
        var e = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", t = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: e, _: Jn() };
        for (var r in Ke)
          Ke[r] === void 0 ? delete t[r] : t[r] = Ke[r];
        var n = [];
        for (var r in t)
          n.push(`${r}=${t[r]}`);
        _e.strings = n;
      }
      return _e.strings;
    }, Kn = (e, t) => {
      for (var r = 0; r < e.length; ++r)
        W[t++] = e.charCodeAt(r);
      W[t] = 0;
    }, Zn = (e, t) => {
      var r = 0;
      return _e().forEach((n, i) => {
        var s = t + r;
        w[e + i * 4 >> 2] = s, Kn(n, s), r += n.length + 1;
      }), 0;
    }, Qn = (e, t) => {
      var r = _e();
      w[e >> 2] = r.length;
      var n = 0;
      return r.forEach((i) => n += i.length + 1), w[t >> 2] = n, 0;
    }, ei = (e) => 52, ti = (e, t, r, n) => 52;
    function ni(e, t, r, n, i) {
      return 70;
    }
    var ii = [null, [], []], ai = (e, t) => {
      var r = ii[e];
      t === 0 || t === 10 ? ((e === 1 ? nr : ee)(bt(r, 0)), r.length = 0) : r.push(t);
    }, oi = (e, t, r, n) => {
      for (var i = 0, s = 0; s < r; s++) {
        var u = w[t >> 2], l = w[t + 4 >> 2];
        t += 8;
        for (var d = 0; d < l; d++)
          ai(e, $[u + d]);
        i += l;
      }
      return w[n >> 2] = i, 0;
    }, si = () => {
      if (typeof crypto == "object" && typeof crypto.getRandomValues == "function")
        return (e) => crypto.getRandomValues(e);
      be("initRandomDevice");
    }, Wt = (e) => (Wt = si())(e), li = (e, t) => (Wt($.subarray(e, e + t)), 0), $e = (e) => e % 4 === 0 && (e % 100 !== 0 || e % 400 === 0), ui = (e, t) => {
      for (var r = 0, n = 0; n <= t; r += e[n++])
        ;
      return r;
    }, Ut = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], Ht = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], di = (e, t) => {
      for (var r = new Date(e.getTime()); t > 0; ) {
        var n = $e(r.getFullYear()), i = r.getMonth(), s = (n ? Ut : Ht)[i];
        if (t > s - r.getDate())
          t -= s - r.getDate() + 1, r.setDate(1), i < 11 ? r.setMonth(i + 1) : (r.setMonth(0), r.setFullYear(r.getFullYear() + 1));
        else
          return r.setDate(r.getDate() + t), r;
      }
      return r;
    };
    function ci(e, t, r) {
      var n = r > 0 ? r : wt(e) + 1, i = new Array(n), s = Et(e, i, 0, i.length);
      return t && (i.length = s), i;
    }
    var vi = (e, t) => {
      W.set(e, t);
    }, fi = (e, t, r, n) => {
      var i = w[n + 40 >> 2], s = { tm_sec: A[n >> 2], tm_min: A[n + 4 >> 2], tm_hour: A[n + 8 >> 2], tm_mday: A[n + 12 >> 2], tm_mon: A[n + 16 >> 2], tm_year: A[n + 20 >> 2], tm_wday: A[n + 24 >> 2], tm_yday: A[n + 28 >> 2], tm_isdst: A[n + 32 >> 2], tm_gmtoff: A[n + 36 >> 2], tm_zone: i ? G(i) : "" }, u = G(r), l = { "%c": "%a %b %d %H:%M:%S %Y", "%D": "%m/%d/%y", "%F": "%Y-%m-%d", "%h": "%b", "%r": "%I:%M:%S %p", "%R": "%H:%M", "%T": "%H:%M:%S", "%x": "%m/%d/%y", "%X": "%H:%M:%S", "%Ec": "%c", "%EC": "%C", "%Ex": "%m/%d/%y", "%EX": "%H:%M:%S", "%Ey": "%y", "%EY": "%Y", "%Od": "%d", "%Oe": "%e", "%OH": "%H", "%OI": "%I", "%Om": "%m", "%OM": "%M", "%OS": "%S", "%Ou": "%u", "%OU": "%U", "%OV": "%V", "%Ow": "%w", "%OW": "%W", "%Oy": "%y" };
      for (var d in l)
        u = u.replace(new RegExp(d, "g"), l[d]);
      var v = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], f = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
      function m(c, p, k) {
        for (var P = typeof c == "number" ? c.toString() : c || ""; P.length < p; )
          P = k[0] + P;
        return P;
      }
      function _(c, p) {
        return m(c, p, "0");
      }
      function C(c, p) {
        function k(Y) {
          return Y < 0 ? -1 : Y > 0 ? 1 : 0;
        }
        var P;
        return (P = k(c.getFullYear() - p.getFullYear())) === 0 && (P = k(c.getMonth() - p.getMonth())) === 0 && (P = k(c.getDate() - p.getDate())), P;
      }
      function T(c) {
        switch (c.getDay()) {
          case 0:
            return new Date(c.getFullYear() - 1, 11, 29);
          case 1:
            return c;
          case 2:
            return new Date(c.getFullYear(), 0, 3);
          case 3:
            return new Date(c.getFullYear(), 0, 2);
          case 4:
            return new Date(c.getFullYear(), 0, 1);
          case 5:
            return new Date(c.getFullYear() - 1, 11, 31);
          case 6:
            return new Date(c.getFullYear() - 1, 11, 30);
        }
      }
      function O(c) {
        var p = di(new Date(c.tm_year + 1900, 0, 1), c.tm_yday), k = new Date(p.getFullYear(), 0, 4), P = new Date(p.getFullYear() + 1, 0, 4), Y = T(k), Ae = T(P);
        return C(Y, p) <= 0 ? C(Ae, p) <= 0 ? p.getFullYear() + 1 : p.getFullYear() : p.getFullYear() - 1;
      }
      var S = { "%a": (c) => v[c.tm_wday].substring(0, 3), "%A": (c) => v[c.tm_wday], "%b": (c) => f[c.tm_mon].substring(0, 3), "%B": (c) => f[c.tm_mon], "%C": (c) => {
        var p = c.tm_year + 1900;
        return _(p / 100 | 0, 2);
      }, "%d": (c) => _(c.tm_mday, 2), "%e": (c) => m(c.tm_mday, 2, " "), "%g": (c) => O(c).toString().substring(2), "%G": O, "%H": (c) => _(c.tm_hour, 2), "%I": (c) => {
        var p = c.tm_hour;
        return p == 0 ? p = 12 : p > 12 && (p -= 12), _(p, 2);
      }, "%j": (c) => _(c.tm_mday + ui($e(c.tm_year + 1900) ? Ut : Ht, c.tm_mon - 1), 3), "%m": (c) => _(c.tm_mon + 1, 2), "%M": (c) => _(c.tm_min, 2), "%n": () => `
`, "%p": (c) => c.tm_hour >= 0 && c.tm_hour < 12 ? "AM" : "PM", "%S": (c) => _(c.tm_sec, 2), "%t": () => "	", "%u": (c) => c.tm_wday || 7, "%U": (c) => {
        var p = c.tm_yday + 7 - c.tm_wday;
        return _(Math.floor(p / 7), 2);
      }, "%V": (c) => {
        var p = Math.floor((c.tm_yday + 7 - (c.tm_wday + 6) % 7) / 7);
        if ((c.tm_wday + 371 - c.tm_yday - 2) % 7 <= 2 && p++, p) {
          if (p == 53) {
            var P = (c.tm_wday + 371 - c.tm_yday) % 7;
            P != 4 && (P != 3 || !$e(c.tm_year)) && (p = 1);
          }
        } else {
          p = 52;
          var k = (c.tm_wday + 7 - c.tm_yday - 1) % 7;
          (k == 4 || k == 5 && $e(c.tm_year % 400 - 1)) && p++;
        }
        return _(p, 2);
      }, "%w": (c) => c.tm_wday, "%W": (c) => {
        var p = c.tm_yday + 7 - (c.tm_wday + 6) % 7;
        return _(Math.floor(p / 7), 2);
      }, "%y": (c) => (c.tm_year + 1900).toString().substring(2), "%Y": (c) => c.tm_year + 1900, "%z": (c) => {
        var p = c.tm_gmtoff, k = p >= 0;
        return p = Math.abs(p) / 60, p = p / 60 * 100 + p % 60, (k ? "+" : "-") + ("0000" + p).slice(-4);
      }, "%Z": (c) => c.tm_zone, "%%": () => "%" };
      u = u.replace(/%%/g, "\0\0");
      for (var d in S)
        u.includes(d) && (u = u.replace(new RegExp(d, "g"), S[d](s)));
      u = u.replace(/\0\0/g, "%");
      var L = ci(u, false);
      return L.length > t ? 0 : (vi(L, e), L.length - 1);
    }, pi = (e, t, r, n, i) => fi(e, t, r, n);
    Pt = o.InternalError = class extends Error {
      constructor(t) {
        super(t), this.name = "InternalError";
      }
    }, xr(), ae = o.BindingError = class extends Error {
      constructor(t) {
        super(t), this.name = "BindingError";
      }
    }, Nr(), Br(), en(), Rt = o.UnboundTypeError = an(Error, "UnboundTypeError"), cn();
    var hi = { c: gr, d: Cr, q: Er, h: yr, F: Pr, V: Tr, S: Lr, W: $r, T: Mr, E: Ar, U: Sr, A: kr, N: Rr, da: Ir, v: on, u: ln, i: un, ca: It, C: pn, n: hn, I: mn, K: gn, p: bn, k: Cn, B: wn, ja: En, J: Pn, z: Sn, w: kn, m: Rn, ea: xn, X: Dn, O: In, ha: jn, P: qe, ga: Bn, ia: Vn, fa: zn, r: Yn, ba: Nn, l: Ot, R: Gn, Y: Zn, Z: Qn, y: ei, D: ti, M: ni, x: oi, _: li, j: Di, g: Bi, f: Hi, aa: ki, s: Ui, G: Oi, t: ji, b: Si, a: Ri, e: xi, o: Wi, H: Ii, $: Vi, L: zi, Q: pi }, b = mr(), Ze = (e) => (Ze = b.ma)(e), Bt = (e) => (Bt = b.na)(e), z = (e) => (z = b.pa)(e), D = (e, t) => (D = b.qa)(e, t), Vt = (e) => (Vt = b.ra)(e), zt = (e) => (zt = b.sa)(e), Yt = () => (Yt = b.ta)(), Nt = (e, t, r) => (Nt = b.ua)(e, t, r), qt = (e) => (qt = b.va)(e);
    o.dynCall_iijj = (e, t, r, n, i, s) => (o.dynCall_iijj = b.wa)(e, t, r, n, i, s);
    o.dynCall_vijj = (e, t, r, n, i, s) => (o.dynCall_vijj = b.xa)(e, t, r, n, i, s);
    o.dynCall_jiii = (e, t, r, n) => (o.dynCall_jiii = b.ya)(e, t, r, n);
    o.dynCall_jii = (e, t, r) => (o.dynCall_jii = b.za)(e, t, r);
    var Xt = o.dynCall_viiij = (e, t, r, n, i, s) => (Xt = o.dynCall_viiij = b.Aa)(e, t, r, n, i, s);
    o.dynCall_jiji = (e, t, r, n, i) => (o.dynCall_jiji = b.Ba)(e, t, r, n, i);
    o.dynCall_viijii = (e, t, r, n, i, s, u) => (o.dynCall_viijii = b.Ca)(e, t, r, n, i, s, u);
    o.dynCall_iiiiij = (e, t, r, n, i, s, u) => (o.dynCall_iiiiij = b.Da)(e, t, r, n, i, s, u);
    o.dynCall_iiiiijj = (e, t, r, n, i, s, u, l, d) => (o.dynCall_iiiiijj = b.Ea)(e, t, r, n, i, s, u, l, d);
    o.dynCall_iiiiiijj = (e, t, r, n, i, s, u, l, d, v) => (o.dynCall_iiiiiijj = b.Fa)(e, t, r, n, i, s, u, l, d, v);
    function Si(e, t) {
      var r = j();
      try {
        R(e)(t);
      } catch (n) {
        if (I(r), n !== n + 0)
          throw n;
        D(1, 0);
      }
    }
    function ki(e, t, r, n, i) {
      var s = j();
      try {
        return R(e)(t, r, n, i);
      } catch (u) {
        if (I(s), u !== u + 0)
          throw u;
        D(1, 0);
      }
    }
    function Ri(e, t, r) {
      var n = j();
      try {
        R(e)(t, r);
      } catch (i) {
        if (I(n), i !== i + 0)
          throw i;
        D(1, 0);
      }
    }
    function xi(e, t, r, n) {
      var i = j();
      try {
        R(e)(t, r, n);
      } catch (s) {
        if (I(i), s !== s + 0)
          throw s;
        D(1, 0);
      }
    }
    function Di(e, t) {
      var r = j();
      try {
        return R(e)(t);
      } catch (n) {
        if (I(r), n !== n + 0)
          throw n;
        D(1, 0);
      }
    }
    function Ii(e, t, r, n, i, s) {
      var u = j();
      try {
        R(e)(t, r, n, i, s);
      } catch (l) {
        if (I(u), l !== l + 0)
          throw l;
        D(1, 0);
      }
    }
    function ji(e) {
      var t = j();
      try {
        R(e)();
      } catch (r) {
        if (I(t), r !== r + 0)
          throw r;
        D(1, 0);
      }
    }
    function Oi(e, t, r, n, i, s, u, l) {
      var d = j();
      try {
        return R(e)(t, r, n, i, s, u, l);
      } catch (v) {
        if (I(d), v !== v + 0)
          throw v;
        D(1, 0);
      }
    }
    function Wi(e, t, r, n, i) {
      var s = j();
      try {
        R(e)(t, r, n, i);
      } catch (u) {
        if (I(s), u !== u + 0)
          throw u;
        D(1, 0);
      }
    }
    function Ui(e, t, r, n, i, s) {
      var u = j();
      try {
        return R(e)(t, r, n, i, s);
      } catch (l) {
        if (I(u), l !== l + 0)
          throw l;
        D(1, 0);
      }
    }
    function Hi(e, t, r, n) {
      var i = j();
      try {
        return R(e)(t, r, n);
      } catch (s) {
        if (I(i), s !== s + 0)
          throw s;
        D(1, 0);
      }
    }
    function Bi(e, t, r) {
      var n = j();
      try {
        return R(e)(t, r);
      } catch (i) {
        if (I(n), i !== i + 0)
          throw i;
        D(1, 0);
      }
    }
    function Vi(e, t, r, n, i, s, u) {
      var l = j();
      try {
        R(e)(t, r, n, i, s, u);
      } catch (d) {
        if (I(l), d !== d + 0)
          throw d;
        D(1, 0);
      }
    }
    function zi(e, t, r, n, i, s) {
      var u = j();
      try {
        Xt(e, t, r, n, i, s);
      } catch (l) {
        if (I(u), l !== l + 0)
          throw l;
        D(1, 0);
      }
    }
    var Me;
    le = function e() {
      Me || Gt(), Me || (le = e);
    };
    function Gt() {
      if (X > 0 || (or(), X > 0))
        return;
      function e() {
        Me || (Me = true, o.calledRun = true, !ut && (sr(), h(o), o.onRuntimeInitialized && o.onRuntimeInitialized(), lr()));
      }
      o.setStatus ? (o.setStatus("Running..."), setTimeout(function() {
        setTimeout(function() {
          o.setStatus("");
        }, 1), e();
      }, 1)) : e();
    }
    if (o.preInit)
      for (typeof o.preInit == "function" && (o.preInit = [o.preInit]); o.preInit.length > 0; )
        o.preInit.pop()();
    return Gt(), N;
  };
})();
var Kt = Xi;
var Z = class {
  constructor() {
    throw new Error("RendererLoader is a static class and cannot be instantiated.");
  }
  static async _tryLoad(a) {
    return await Kt({ locateFile: () => a });
  }
  static async _loadWithBackup() {
    return this._ModulePromise || (this._ModulePromise = this._tryLoad(this._wasmURL).catch(async (a) => {
      let o = `https://unpkg.com/${me.name}@${me.version}/dist/dotlottie-player.wasm`;
      console.warn(`Primary WASM load failed from ${this._wasmURL}. Error: ${a.message}`), console.warn(`Attempting to load WASM from backup URL: ${o}`);
      try {
        return await this._tryLoad(o);
      } catch (h) {
        throw console.error(`Primary WASM URL failed: ${a.message}`), console.error(`Backup WASM URL failed: ${h.message}`), new Error("WASM loading failed from all sources.");
      }
    })), this._ModulePromise;
  }
  static async load() {
    return this._loadWithBackup();
  }
  static setWasmUrl(a) {
    this._wasmURL = a, this._ModulePromise = null;
  }
};
F(Z, "_ModulePromise", null), F(Z, "_wasmURL", `https://cdn.jsdelivr.net/npm/${me.name}@${me.version}/dist/dotlottie-player.wasm`);
var ke = class {
  constructor() {
    F(this, "_eventListeners", /* @__PURE__ */ new Map());
  }
  addEventListener(a, o) {
    let h = this._eventListeners.get(a);
    h || (h = /* @__PURE__ */ new Set(), this._eventListeners.set(a, h)), h.add(o);
  }
  removeEventListener(a, o) {
    let h = this._eventListeners.get(a);
    h && (o ? (h.delete(o), h.size === 0 && this._eventListeners.delete(a)) : this._eventListeners.delete(a));
  }
  dispatch(a) {
    this._eventListeners.get(a.type)?.forEach((h) => h(a));
  }
  removeAllEventListeners() {
    this._eventListeners.clear();
  }
};
var nt = (y, a) => y === "reverse" ? a.Mode.Reverse : y === "bounce" ? a.Mode.Bounce : y === "reverse-bounce" ? a.Mode.ReverseBounce : a.Mode.Forward;
var it = (y, a) => y === "contain" ? a.Fit.Contain : y === "cover" ? a.Fit.Cover : y === "fill" ? a.Fit.Fill : y === "fit-height" ? a.Fit.FitHeight : y === "fit-width" ? a.Fit.FitWidth : a.Fit.None;
var at = (y, a) => {
  let o = new a.VectorFloat();
  return o.push_back(y[0]), o.push_back(y[1]), o;
};
var ot = (y, a) => {
  let o = new a.VectorFloat();
  return y.length !== 2 || (o.push_back(y[0]), o.push_back(y[1])), o;
};
var Zt = class {
  constructor(a) {
    F(this, "_canvas");
    F(this, "_context");
    F(this, "_eventManager");
    F(this, "_animationFrameId", null);
    F(this, "_frameManager");
    F(this, "_dotLottieCore", null);
    F(this, "_wasmModule", null);
    F(this, "_renderConfig", {});
    F(this, "_isFrozen", false);
    F(this, "_backgroundColor", null);
    this._canvas = a.canvas, this._context = this._canvas.getContext("2d"), this._eventManager = new ke(), this._frameManager = new Se(), this._renderConfig = a.renderConfig ?? {}, Z.load().then((o) => {
      this._wasmModule = o, this._dotLottieCore = new o.DotLottiePlayer({ autoplay: a.autoplay ?? false, backgroundColor: 0, loopAnimation: a.loop ?? false, mode: nt(a.mode ?? "forward", o), segment: ot(a.segment ?? [], o), speed: a.speed ?? 1, useFrameInterpolation: a.useFrameInterpolation ?? true, marker: a.marker ?? "", layout: a.layout ? { align: at(a.layout.align, o), fit: it(a.layout.fit, o) } : o.createDefaultLayout() }), a.data ? this._loadFromData(a.data) : a.src && this._loadFromSrc(a.src), a.backgroundColor && this.setBackgroundColor(a.backgroundColor);
    }).catch((o) => {
      this._eventManager.dispatch({ type: "loadError", error: new Error(`Failed to load wasm module: ${o}`) });
    });
  }
  _loadFromSrc(a) {
    async function o() {
      let h = await fetch(a);
      if (!h.ok)
        throw new Error(`Failed to fetch the animation data from URL: ${a}. ${h.status}: ${h.statusText}`);
      let E = (h.headers.get("content-type") ?? "").trim(), N;
      return ["application/json", "text/plain"].some((Q) => E.startsWith(Q)) ? N = await h.text() : N = await h.arrayBuffer(), N;
    }
    o().then((h) => {
      this._loadFromData(h);
    }).catch((h) => {
      this._eventManager.dispatch({ type: "loadError", error: new Error(`Failed to load animation data from URL: ${a}. ${h}`) });
    });
  }
  _loadFromData(a) {
    if (this._dotLottieCore === null)
      return;
    let o = this._canvas.width, h = this._canvas.height, E = false;
    if (typeof a == "string")
      E = this._dotLottieCore.loadAnimationData(a, o, h);
    else if (a instanceof ArrayBuffer)
      E = this._dotLottieCore.loadDotLottieData(a, o, h);
    else if (typeof a == "object")
      E = this._dotLottieCore.loadAnimationData(JSON.stringify(a), o, h);
    else {
      this._eventManager.dispatch({ type: "loadError", error: new Error("Unsupported data type for animation data. Expected a string or ArrayBuffer.") });
      return;
    }
    E ? (this._eventManager.dispatch({ type: "load" }), rt && this.resize(), this._eventManager.dispatch({ type: "frame", currentFrame: this._dotLottieCore.currentFrame() }), this._render(), this._dotLottieCore.config().autoplay && (this._dotLottieCore.play(), this._dotLottieCore.isPlaying() ? (this._eventManager.dispatch({ type: "play" }), this._animationFrameId = this._frameManager.requestAnimationFrame(this._draw.bind(this))) : console.error("something went wrong, the animation was suppose to autoplay"))) : this._eventManager.dispatch({ type: "loadError", error: new Error("Failed to load animation data") });
  }
  get activeAnimationId() {
    return this._dotLottieCore?.activeAnimationId();
  }
  get activeThemeId() {
    return this._dotLottieCore?.activeThemeId();
  }
  get layout() {
    let a = this._dotLottieCore?.config().layout;
    if (a)
      return { align: [a.align.get(0), a.align.get(1)], fit: (() => {
        switch (a.fit) {
          case this._wasmModule?.Fit.Contain:
            return "contain";
          case this._wasmModule?.Fit.Cover:
            return "cover";
          case this._wasmModule?.Fit.Fill:
            return "fill";
          case this._wasmModule?.Fit.FitHeight:
            return "fit-height";
          case this._wasmModule?.Fit.FitWidth:
            return "fit-width";
          case this._wasmModule?.Fit.None:
            return "none";
          default:
            return "contain";
        }
      })() };
  }
  get marker() {
    return this._dotLottieCore?.config().marker;
  }
  get manifest() {
    try {
      let a = this._dotLottieCore?.manifestString();
      if (this._dotLottieCore === null || !a)
        return null;
      let o = JSON.parse(a);
      return Object.keys(o).length === 0 ? null : o;
    } catch {
      return null;
    }
  }
  get renderConfig() {
    return this._renderConfig;
  }
  get segment() {
    let a = this._dotLottieCore?.config().segment;
    if (a && a.size() === 2)
      return [a.get(0), a.get(1)];
  }
  get loop() {
    return this._dotLottieCore?.config().loopAnimation ?? false;
  }
  get mode() {
    let a = this._dotLottieCore?.config().mode;
    return a === this._wasmModule?.Mode.Reverse ? "reverse" : a === this._wasmModule?.Mode.Bounce ? "bounce" : a === this._wasmModule?.Mode.ReverseBounce ? "reverse-bounce" : "forward";
  }
  get isFrozen() {
    return this._isFrozen;
  }
  get backgroundColor() {
    return this._backgroundColor ?? "";
  }
  get autoplay() {
    return this._dotLottieCore?.config().autoplay ?? false;
  }
  get useFrameInterpolation() {
    return this._dotLottieCore?.config().useFrameInterpolation ?? false;
  }
  get speed() {
    return this._dotLottieCore?.config().speed ?? 0;
  }
  get isLoaded() {
    return this._dotLottieCore?.isLoaded() ?? false;
  }
  get isPlaying() {
    return this._dotLottieCore?.isPlaying() ?? false;
  }
  get isPaused() {
    return this._dotLottieCore?.isPaused() ?? false;
  }
  get isStopped() {
    return this._dotLottieCore?.isStopped() ?? false;
  }
  get currentFrame() {
    return this._dotLottieCore?.currentFrame() ?? 0;
  }
  get loopCount() {
    return this._dotLottieCore?.loopCount() ?? 0;
  }
  get totalFrames() {
    return this._dotLottieCore?.totalFrames() ?? 0;
  }
  get duration() {
    return this._dotLottieCore?.duration() ?? 0;
  }
  get segmentDuration() {
    return this._dotLottieCore?.segmentDuration() ?? 0;
  }
  get canvas() {
    return this._canvas;
  }
  load(a) {
    this._dotLottieCore === null || this._wasmModule === null || (this._dotLottieCore.setConfig({ autoplay: a.autoplay ?? false, backgroundColor: 0, loopAnimation: a.loop ?? false, mode: nt(a.mode ?? "forward", this._wasmModule), segment: ot(a.segment ?? [], this._wasmModule), speed: a.speed ?? 1, useFrameInterpolation: a.useFrameInterpolation ?? true, marker: a.marker ?? "", layout: a.layout ? { align: at(a.layout.align, this._wasmModule), fit: it(a.layout.fit, this._wasmModule) } : this._wasmModule.createDefaultLayout() }), a.data ? this._loadFromData(a.data) : a.src && this._loadFromSrc(a.src), this.setBackgroundColor(a.backgroundColor ?? ""));
  }
  _render() {
    if (this._dotLottieCore === null || this._context === null)
      return false;
    if (this._dotLottieCore.render()) {
      let o = this._dotLottieCore.buffer(), h = new Uint8ClampedArray(o, 0, this._canvas.width * this._canvas.height * 4), E = null;
      return typeof ImageData > "u" ? (E = this._context.createImageData(this._canvas.width, this._canvas.height), E.data.set(h)) : E = new ImageData(h, this._canvas.width, this._canvas.height), this._context.putImageData(E, 0, 0), this._eventManager.dispatch({ type: "render", currentFrame: this._dotLottieCore.currentFrame() }), true;
    }
    return false;
  }
  _draw() {
    if (this._dotLottieCore === null || this._context === null || !this._dotLottieCore.isPlaying())
      return;
    let a = this._dotLottieCore.requestFrame();
    this._dotLottieCore.setFrame(a) && (this._eventManager.dispatch({ type: "frame", currentFrame: this._dotLottieCore.currentFrame() }), this._render() && this._dotLottieCore.isComplete() && (this._dotLottieCore.config().loopAnimation ? this._eventManager.dispatch({ type: "loop", loopCount: this._dotLottieCore.loopCount() }) : this._eventManager.dispatch({ type: "complete" }))), this._animationFrameId = this._frameManager.requestAnimationFrame(this._draw.bind(this));
  }
  play() {
    if (this._dotLottieCore === null)
      return;
    let a = this._dotLottieCore.play();
    this._isFrozen = false, a && (this._eventManager.dispatch({ type: "play" }), this._animationFrameId = this._frameManager.requestAnimationFrame(this._draw.bind(this)));
  }
  pause() {
    if (this._dotLottieCore === null)
      return;
    this._dotLottieCore.pause() && this._eventManager.dispatch({ type: "pause" });
  }
  stop() {
    if (this._dotLottieCore === null)
      return;
    this._dotLottieCore.stop() && (this._eventManager.dispatch({ type: "frame", currentFrame: this._dotLottieCore.currentFrame() }), this._render(), this._eventManager.dispatch({ type: "stop" }));
  }
  setFrame(a) {
    if (this._dotLottieCore === null || a < 0 || a > this._dotLottieCore.totalFrames())
      return;
    this._dotLottieCore.seek(a) && (this._eventManager.dispatch({ type: "frame", currentFrame: this._dotLottieCore.currentFrame() }), this._render());
  }
  setSpeed(a) {
    this._dotLottieCore !== null && this._dotLottieCore.setConfig({ ...this._dotLottieCore.config(), speed: a });
  }
  setBackgroundColor(a) {
    this._dotLottieCore !== null && (this._canvas instanceof HTMLCanvasElement && (this._canvas.style.backgroundColor = a), this._backgroundColor = a);
  }
  setLoop(a) {
    this._dotLottieCore !== null && this._dotLottieCore.setConfig({ ...this._dotLottieCore.config(), loopAnimation: a });
  }
  setUseFrameInterpolation(a) {
    this._dotLottieCore !== null && this._dotLottieCore.setConfig({ ...this._dotLottieCore.config(), useFrameInterpolation: a });
  }
  addEventListener(a, o) {
    this._eventManager.addEventListener(a, o);
  }
  removeEventListener(a, o) {
    this._eventManager.removeEventListener(a, o);
  }
  destroy() {
    this._dotLottieCore?.delete(), this._dotLottieCore = null, this._context = null, this._eventManager.dispatch({ type: "destroy" }), this._eventManager.removeAllEventListeners(), this._cleanupStateMachineListeners();
  }
  freeze() {
    this._animationFrameId !== null && (this._frameManager.cancelAnimationFrame(this._animationFrameId), this._animationFrameId = null, this._isFrozen = true, this._eventManager.dispatch({ type: "freeze" }));
  }
  unfreeze() {
    this._animationFrameId === null && (this._animationFrameId = this._frameManager.requestAnimationFrame(this._draw.bind(this)), this._isFrozen = false, this._eventManager.dispatch({ type: "unfreeze" }));
  }
  resize() {
    if (rt && this._canvas instanceof HTMLCanvasElement) {
      let o = this._renderConfig.devicePixelRatio || window.devicePixelRatio || 1, { height: h, width: E } = this._canvas.getBoundingClientRect();
      this._canvas.width = E * o, this._canvas.height = h * o;
    }
    this._dotLottieCore?.resize(this._canvas.width, this._canvas.height) && this._render();
  }
  setSegment(a, o) {
    this._dotLottieCore === null || this._wasmModule === null || this._dotLottieCore.setConfig({ ...this._dotLottieCore.config(), segment: ot([a, o], this._wasmModule) });
  }
  setMode(a) {
    this._dotLottieCore === null || this._wasmModule === null || this._dotLottieCore.setConfig({ ...this._dotLottieCore.config(), mode: nt(a, this._wasmModule) });
  }
  setRenderConfig(a) {
    this._renderConfig = a;
  }
  loadAnimation(a) {
    if (this._dotLottieCore === null)
      return;
    this._dotLottieCore.loadAnimation(a, this._canvas.width, this._canvas.height) ? (this._eventManager.dispatch({ type: "load" }), this.resize()) : this._eventManager.dispatch({ type: "loadError", error: new Error(`Failed to animation :${a}`) });
  }
  setMarker(a) {
    this._dotLottieCore !== null && this._dotLottieCore.setConfig({ ...this._dotLottieCore.config(), marker: a });
  }
  markers() {
    let a = this._dotLottieCore?.markers();
    if (a) {
      let o = [];
      for (let h = 0; h < a.size(); h += 1) {
        let E = a.get(h);
        o.push({ name: E.name, time: E.time, duration: E.duration });
      }
      return o;
    }
    return [];
  }
  loadTheme(a) {
    if (this._dotLottieCore === null)
      return false;
    let o = this._dotLottieCore.loadTheme(a);
    return this._render(), o;
  }
  loadThemeData(a) {
    if (this._dotLottieCore === null)
      return false;
    let o = this._dotLottieCore.loadThemeData(a);
    return this._render(), o;
  }
  setLayout(a) {
    this._dotLottieCore === null || this._wasmModule === null || this._dotLottieCore.setConfig({ ...this._dotLottieCore.config(), layout: { align: at(a.align, this._wasmModule), fit: it(a.fit, this._wasmModule) } });
  }
  setViewport(a, o, h, E) {
    return this._dotLottieCore === null ? false : this._dotLottieCore.setViewport(a, o, h, E);
  }
  static setWasmUrl(a) {
    Z.setWasmUrl(a);
  }
  loadStateMachine(a) {
    return this._dotLottieCore?.loadStateMachine(a) ?? false;
  }
  startStateMachine() {
    let a = this._dotLottieCore?.startStateMachine() ?? false;
    return a && this._setupStateMachineListeners(), a;
  }
  stopStateMachine() {
    let a = this._dotLottieCore?.stopStateMachine() ?? false;
    return a && this._cleanupStateMachineListeners(), a;
  }
  _getPointerPosition(a) {
    let o = this._canvas.getBoundingClientRect(), h = this._canvas.width / o.width, E = this._canvas.height / o.height, N = this._renderConfig.devicePixelRatio || window.devicePixelRatio || 1, Q = (a.clientX - o.left) * h / N, Re = (a.clientY - o.top) * E / N;
    return { x: Q, y: Re };
  }
  _onPointerUp(a) {
    let { x: o, y: h } = this._getPointerPosition(a);
    this.postStateMachineEvent(`OnPointerUp: ${o} ${h}`);
  }
  _onPointerDown(a) {
    let { x: o, y: h } = this._getPointerPosition(a);
    this.postStateMachineEvent(`OnPointerDown: ${o} ${h}`);
  }
  _onPointerMove(a) {
    let { x: o, y: h } = this._getPointerPosition(a);
    this.postStateMachineEvent(`OnPointerMove: ${o} ${h}`);
  }
  _onPointerEnter(a) {
    let { x: o, y: h } = this._getPointerPosition(a);
    this.postStateMachineEvent(`OnPointerEnter: ${o} ${h}`);
  }
  _onPointerLeave(a) {
    let { x: o, y: h } = this._getPointerPosition(a);
    this.postStateMachineEvent(`OnPointerExit: ${o} ${h}`);
  }
  _onComplete() {
    this.postStateMachineEvent("OnComplete");
  }
  postStateMachineEvent(a) {
    return this._dotLottieCore?.postEventPayload(a) ?? false;
  }
  _setupStateMachineListeners() {
    if (this._canvas instanceof HTMLCanvasElement && this._dotLottieCore !== null && this.isLoaded) {
      let a = this._dotLottieCore.stateMachineFrameworkSetup(), o = [];
      for (let h = 0; h < a.size(); h += 1)
        o.push(a.get(h));
      o.includes("PointerUp") && this._canvas.addEventListener("pointerup", this._onPointerUp.bind(this)), o.includes("PointerDown") && this._canvas.addEventListener("pointerdown", this._onPointerDown.bind(this)), o.includes("PointerMove") && this._canvas.addEventListener("pointermove", this._onPointerMove.bind(this)), o.includes("PointerEnter") && this._canvas.addEventListener("pointerenter", this._onPointerEnter.bind(this)), o.includes("PointerExit") && this._canvas.addEventListener("pointerleave", this._onPointerLeave.bind(this)), o.includes("Complete") && this.addEventListener("complete", this._onComplete.bind(this));
    }
  }
  _cleanupStateMachineListeners() {
    this._canvas instanceof HTMLCanvasElement && (this._canvas.removeEventListener("pointerup", this._onPointerUp.bind(this)), this._canvas.removeEventListener("pointerdown", this._onPointerDown.bind(this)), this._canvas.removeEventListener("pointermove", this._onPointerMove.bind(this)), this._canvas.removeEventListener("pointerenter", this._onPointerEnter.bind(this)), this._canvas.removeEventListener("pointerleave", this._onPointerLeave.bind(this)), this.removeEventListener("complete", this._onComplete.bind(this)));
  }
};

// src/use-dotlottie.tsx
var import_debounce = __toESM(require_debounce(), 1);
function DotLottieComponent({
  children,
  className = "",
  setCanvasRef,
  setContainerRef,
  style,
  ...rest
}) {
  const containerStyle = {
    width: "100%",
    height: "100%",
    ...style
  };
  return /* @__PURE__ */ React.createElement("div", { ref: setContainerRef, className, ...!className && { style: containerStyle } }, /* @__PURE__ */ React.createElement(
    "canvas",
    {
      ref: setCanvasRef,
      style: {
        width: "100%",
        height: "100%"
      },
      ...rest
    },
    children
  ));
}
var isServerSide = () => typeof window === "undefined";
var useDotLottie = (config) => {
  const [dotLottie, setDotLottie] = useState(null);
  const dotLottieRef = useRef(null);
  const configRef = useRef(config);
  const canvasRef = useRef(null);
  const containerRef = useRef(null);
  dotLottieRef.current = dotLottie;
  configRef.current = config;
  const hoverHandler = useCallback((event) => {
    if (!configRef.current?.playOnHover || !dotLottieRef.current?.isLoaded)
      return;
    if (event.type === "mouseenter") {
      dotLottieRef.current.play();
    } else if (event.type === "mouseleave") {
      dotLottieRef.current.pause();
    }
  }, []);
  const intersectionObserver = useMemo(() => {
    if (isServerSide())
      return null;
    const observerCallback = (0, import_debounce.default)((entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          dotLottieRef.current?.unfreeze();
        } else {
          dotLottieRef.current?.freeze();
        }
      });
    }, 150);
    return new IntersectionObserver(observerCallback, {
      threshold: 0
    });
  }, []);
  const resizeObserver = useMemo(() => {
    if (isServerSide())
      return null;
    const observerCallback = (0, import_debounce.default)(() => {
      if (configRef.current?.autoResizeCanvas) {
        dotLottieRef.current?.resize();
      }
    }, 150);
    return new ResizeObserver(observerCallback);
  }, []);
  const setCanvasRef = useCallback((canvas) => {
    canvasRef.current = canvas;
  }, []);
  const setContainerRef = useCallback((container) => {
    containerRef.current = container;
  }, []);
  const Component = useCallback(
    (props) => {
      return /* @__PURE__ */ React.createElement(DotLottieComponent, { setContainerRef, setCanvasRef, ...props });
    },
    [setCanvasRef, setContainerRef]
  );
  useEffect(() => {
    const canvas = canvasRef.current;
    let dotLottieInstance = null;
    if (canvas) {
      dotLottieInstance = new Zt({
        ...configRef.current,
        canvas
      });
      const initialEntry = canvas.getBoundingClientRect();
      if (initialEntry.top >= 0 && initialEntry.left >= 0 && initialEntry.bottom <= (window.innerHeight || document.documentElement.clientHeight) && initialEntry.right <= (window.innerWidth || document.documentElement.clientWidth)) {
        dotLottieInstance.unfreeze();
      } else {
        dotLottieInstance.freeze();
      }
      intersectionObserver?.observe(canvas);
      if (config?.autoResizeCanvas) {
        resizeObserver?.observe(canvas);
      }
      canvas.addEventListener("mouseenter", hoverHandler);
      canvas.addEventListener("mouseleave", hoverHandler);
      setDotLottie(dotLottieInstance);
    }
    return () => {
      dotLottieInstance?.destroy();
      setDotLottie(null);
      resizeObserver?.disconnect();
      intersectionObserver?.disconnect();
      canvas?.removeEventListener("mouseenter", hoverHandler);
      canvas?.removeEventListener("mouseleave", hoverHandler);
    };
  }, [intersectionObserver, resizeObserver, hoverHandler]);
  useEffect(() => {
    if (!dotLottieRef.current)
      return;
    if (typeof config?.speed === "number" && config.speed !== dotLottieRef.current.speed) {
      dotLottieRef.current.setSpeed(config.speed);
    }
  }, [config?.speed]);
  useEffect(() => {
    if (!dotLottieRef.current)
      return;
    if (typeof config?.mode === "string" && config.mode !== dotLottieRef.current.mode) {
      dotLottieRef.current.setMode(config.mode);
    }
  }, [config?.mode]);
  useEffect(() => {
    if (!dotLottieRef.current)
      return;
    if (typeof config?.loop === "boolean" && config.loop !== dotLottieRef.current.loop) {
      dotLottieRef.current.setLoop(config.loop);
    }
  }, [config?.loop]);
  useEffect(() => {
    if (!dotLottieRef.current)
      return;
    if (typeof config?.useFrameInterpolation === "boolean" && config.useFrameInterpolation !== dotLottieRef.current.useFrameInterpolation) {
      dotLottieRef.current.setUseFrameInterpolation(config.useFrameInterpolation);
    }
  }, [config?.useFrameInterpolation]);
  useEffect(() => {
    if (!dotLottieRef.current)
      return;
    if (typeof config?.segment === "object" && Array.isArray(config.segment) && // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    config.segment.length === 2) {
      const startFrame = config.segment[0];
      const endFrame = config.segment[1];
      dotLottieRef.current.setSegment(startFrame, endFrame);
    }
  }, [config?.segment]);
  useEffect(() => {
    if (!dotLottieRef.current)
      return;
    if (typeof config?.backgroundColor === "string" && config.backgroundColor !== dotLottieRef.current.backgroundColor) {
      dotLottieRef.current.setBackgroundColor(config.backgroundColor);
    }
  }, [config?.backgroundColor]);
  useEffect(() => {
    if (!dotLottieRef.current)
      return;
    if (typeof config?.renderConfig === "object") {
      dotLottieRef.current.setRenderConfig(config.renderConfig);
    }
  }, [JSON.stringify(config?.renderConfig)]);
  useEffect(() => {
    if (!dotLottieRef.current)
      return;
    if (typeof config?.data === "string" || config?.data instanceof ArrayBuffer) {
      dotLottieRef.current.load({
        data: config.data,
        ...configRef.current || {}
      });
    }
  }, [config?.data]);
  useEffect(() => {
    if (!dotLottieRef.current)
      return;
    if (typeof config?.src === "string") {
      dotLottieRef.current.load({
        src: config.src,
        ...configRef.current || {}
      });
    }
  }, [config?.src]);
  useEffect(() => {
    if (!dotLottieRef.current)
      return;
    if (typeof config?.marker === "string") {
      dotLottieRef.current.setMarker(config.marker);
    }
  }, [config?.marker]);
  useEffect(() => {
    if (!resizeObserver)
      return;
    if (config?.autoResizeCanvas && canvasRef.current) {
      resizeObserver.observe(canvasRef.current);
    } else {
      resizeObserver.disconnect();
    }
  }, [config?.autoResizeCanvas, resizeObserver]);
  return {
    dotLottie,
    setCanvasRef,
    setContainerRef,
    canvas: canvasRef.current,
    container: containerRef.current,
    DotLottieComponent: Component
  };
};
var setWasmUrl = (url) => {
  Zt.setWasmUrl(url);
};
var useIsomorphicLayoutEffect = typeof window !== "undefined" ? useLayoutEffect : useEffect;
function useStableCallback(callback) {
  const callbackContainer = useRef(callback);
  useIsomorphicLayoutEffect(() => {
    callbackContainer.current = callback;
  });
  return useCallback((...args) => callbackContainer.current(...args), [callbackContainer]);
}

// src/dotlottie.tsx
var DotLottieReact = ({
  autoResizeCanvas = true,
  autoplay,
  backgroundColor,
  data,
  dotLottieRefCallback,
  loop,
  marker,
  mode,
  playOnHover,
  renderConfig,
  segment,
  speed,
  src,
  useFrameInterpolation,
  ...props
}) => {
  const { DotLottieComponent: DotLottieComponent2, dotLottie } = useDotLottie({
    data,
    mode,
    speed,
    src,
    autoplay,
    loop,
    segment,
    renderConfig,
    backgroundColor,
    useFrameInterpolation,
    playOnHover,
    autoResizeCanvas,
    marker
  });
  const stableDotLottieRefCallback = typeof dotLottieRefCallback === "function" ? useStableCallback(dotLottieRefCallback) : void 0;
  React.useEffect(() => {
    if (typeof stableDotLottieRefCallback === "function") {
      stableDotLottieRefCallback(dotLottie);
    }
  }, [stableDotLottieRefCallback, dotLottie]);
  return /* @__PURE__ */ React.createElement(DotLottieComponent2, { ...props });
};

export { DotLottieReact, setWasmUrl, useDotLottie };
